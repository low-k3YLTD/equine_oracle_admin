// routers.ts - Predictions Analytics Router
import { z } from 'zod';
import { router, publicProcedure, protectedProcedure } from '../trpc';
import {
  accuracyMetricsSchema,
  predictionHistorySchema,
  predictionFilterSchema,
  csvUploadSchema,
  analyticsDashboardSchema,
} from './schema';

// ============================================================================
// PREDICTIONS ROUTER (Extended with Analytics - Phase 3-4)
// ============================================================================
export const predictionsRouter = router({
  // -------------------------------------------------------------------------
  // ANALYTICS ENDPOINT - Aggregate Performance Metrics
  // -------------------------------------------------------------------------
  analytics: protectedProcedure
    .input(
      z.object({
        startDate: z.date().optional(),
        endDate: z.date().optional(),
        trackFilter: z.string().optional(),
        includeModelBreakdown: z.boolean().default(true),
      })
    )
    .query(async ({ input, ctx }) => {
      const { startDate, endDate, trackFilter, includeModelBreakdown } = input;
      
      // Query prediction history with filters
      const predictions = await ctx.db.predictionHistory.findMany({
        where: {
          raceDate: {
            gte: startDate || new Date(Date.now() - 90 * 24 * 60 * 60 * 1000), // Default: last 90 days
            lte: endDate || new Date(),
          },
          ...(trackFilter && { trackName: trackFilter }),
        },
        include: {
          race: true,
          modelScores: includeModelBreakdown,
        },
      });

      // Calculate aggregate metrics
      const totalPredictions = predictions.length;
      const settledPredictions = predictions.filter(p => p.actualPosition !== null);
      
      // Top-1 Accuracy (5-8% improvement target)
      const correctWinners = settledPredictions.filter(p => p.predictedPosition === 1 && p.actualPosition === 1);
      const top1Accuracy = settledPredictions.length > 0 
        ? correctWinners.length / settledPredictions.length 
        : 0;

      // Top-3 Hit Rate (3-5% improvement target)
      const top3Hits = settledPredictions.filter(p => 
        p.predictedPosition <= 3 && p.actualPosition !== null && p.actualPosition <= 3
      );
      const top3HitRate = settledPredictions.length > 0
        ? top3Hits.length / settledPredictions.length
        : 0;

      // ROI Calculation (NEW)
      const roiData = settledPredictions.reduce((acc, pred) => {
        if (pred.actualPosition === 1 && pred.predictedPosition === 1 && pred.closingOdds) {
          acc.profit += (pred.closingOdds - 1); // Assuming $1 unit bet
          acc.totalBets += 1;
        } else if (pred.predictedPosition === 1) {
          acc.totalBets += 1; // Lost bet
        }
        return acc;
      }, { profit: 0, totalBets: 0 });

      const roi = roiData.totalBets > 0 
        ? (roiData.profit / roiData.totalBets) * 100 
        : 0;

      // Market Beat Rate (NEW)
      const marketBeats = settledPredictions.filter(pred => {
        if (!pred.startingOdds || pred.actualPosition !== 1) return false;
        const impliedProbability = 1 / pred.startingOdds;
        return pred.predictedProbability > impliedProbability;
      });
      const marketBeatRate = settledPredictions.length > 0
        ? marketBeats.length / settledPredictions.length
        : 0;

      // Calibration Error
      const calibrationBins = 10;
      const binSize = 1 / calibrationBins;
      let calibrationError = 0;
      
      for (let i = 0; i < calibrationBins; i++) {
        const binMin = i * binSize;
        const binMax = (i + 1) * binSize;
        const binPredictions = settledPredictions.filter(
          p => p.predictedProbability >= binMin && p.predictedProbability < binMax
        );
        
        if (binPredictions.length > 0) {
          const avgPredicted = binPredictions.reduce((sum, p) => sum + p.predictedProbability, 0) / binPredictions.length;
          const actualWinRate = binPredictions.filter(p => p.actualPosition === 1).length / binPredictions.length;
          calibrationError += Math.abs(avgPredicted - actualWinRate) * (binPredictions.length / settledPredictions.length);
        }
      }

      // Model breakdown (if requested)
      let modelBreakdown = undefined;
      if (includeModelBreakdown) {
        const models = ['LightGBM_Ranker', 'XGBoost', 'LogisticRegression', 'LightGBM_Old'];
        modelBreakdown = models.map(modelName => {
          const modelPredictions = predictions.filter(p => 
            p.modelScores?.some(s => s.modelName === modelName)
          );
          const modelCorrect = modelPredictions.filter(p => 
            p.actualPosition === 1 && p.predictedPosition === 1
          );
          
          return {
            modelName,
            accuracy: modelPredictions.length > 0 ? modelCorrect.length / modelPredictions.length : 0,
            weight: getModelWeight(modelName), // From weighted ensemble config
            status: 'active' as const,
          };
        });
      }

      // Construct response matching accuracyMetricsSchema
      return {
        top1Accuracy,
        top3HitRate,
        top5HitRate: 0, // Placeholder - extend as needed
        ndcg1: 0.9529, // From evaluation report - should be calculated dynamically
        ndcg3: 0.9529,
        ndcg4: 0.9529,
        roi,
        marketBeatRate,
        averageOdds: settledPredictions.reduce((sum, p) => sum + (p.closingOdds || 0), 0) / settledPredictions.length,
        profitLoss: roiData.profit,
        sharpeRatio: undefined, // Requires variance calculation
        calibrationError,
        brierScore: undefined, // Optional extension
        evaluationPeriod: {
          startDate: startDate || new Date(Date.now() - 90 * 24 * 60 * 60 * 1000),
          endDate: endDate || new Date(),
          totalRaces: new Set(predictions.map(p => p.raceId)).size,
          totalPredictions,
        },
        modelBreakdown,
        lastUpdated: new Date(),
        dataVersion: 'v3',
      } satisfies z.infer<typeof accuracyMetricsSchema>;
    }),

  // -------------------------------------------------------------------------
  // PREDICTION HISTORY - With Filters & Pagination
  // -------------------------------------------------------------------------
  history: protectedProcedure
    .input(predictionFilterSchema)
    .query(async ({ input, ctx }) => {
      const { 
        trackName, trackCode, horseName, dateFrom, dateTo, 
        minConfidence, resultStatus, page, pageSize, sortBy, sortOrder 
      } = input;

      const where: any = {};
      
      if (trackName) where.trackName = { contains: trackName, mode: 'insensitive' };
      if (trackCode) where.trackCode = trackCode;
      if (horseName) where.horseName = { contains: horseName, mode: 'insensitive' };
      if (dateFrom || dateTo) {
        where.raceDate = {};
        if (dateFrom) where.raceDate.gte = dateFrom;
        if (dateTo) where.raceDate.lte = dateTo;
      }
      if (minConfidence) where.confidenceScore = { gte: minConfidence };
      
      if (resultStatus !== 'all') {
        if (resultStatus === 'won') where.isWinner = true;
        else if (resultStatus === 'top3') where.isTop3 = true;
        else if (resultStatus === 'pending') where.actualPosition = null;
      }

      const orderByMap: Record<string, any> = {
        date: { raceDate: sortOrder },
        confidence: { confidenceScore: sortOrder },
        odds: { closingOdds: sortOrder },
        result: { actualPosition: sortOrder },
      };

      const [predictions, total] = await Promise.all([
        ctx.db.predictionHistory.findMany({
          where,
          orderBy: orderByMap[sortBy],
          skip: (page - 1) * pageSize,
          take: pageSize,
        }),
        ctx.db.predictionHistory.count({ where }),
      ]);

      return {
        predictions,
        pagination: {
          page,
          pageSize,
          total,
          totalPages: Math.ceil(total / pageSize),
        },
      };
    }),

  // -------------------------------------------------------------------------
  // CSV EXPORT
  // -------------------------------------------------------------------------
  exportCsv: protectedProcedure
    .input(predictionFilterSchema.omit({ page: true, pageSize: true }))
    .mutation(async ({ input, ctx }) => {
      const predictions = await ctx.db.predictionHistory.findMany({
        where: buildWhereClause(input), // Reuse filter logic
        orderBy: { raceDate: 'desc' },
      });

      const csv = [
        // CSV header
        [
          'Race Date', 'Track', 'Horse', 'Jockey', 'Trainer',
          'Predicted Position', 'Actual Position', 'Confidence',
          'Starting Odds', 'Closing Odds', 'Won', 'Top 3', 'Model Version'
        ].join(','),
        // CSV rows
        ...predictions.map(p => [
          p.raceDate.toISOString().split('T')[0],
          p.trackName,
          p.horseName,
          p.jockey || '',
          p.trainer || '',
          p.predictedPosition,
          p.actualPosition ?? 'N/A',
          p.confidenceScore.toFixed(4),
          p.startingOdds?.toFixed(2) ?? '',
          p.closingOdds?.toFixed(2) ?? '',
          p.isWinner ? 'Yes' : 'No',
          p.isTop3 ? 'Yes' : 'No',
          p.modelVersion,
        ].join(','))
      ].join('\n');

      return {
        csv,
        fileName: `equine-oracle-predictions-${new Date().toISOString().split('T')[0]}.csv`,
        rowCount: predictions.length,
      };
    }),

  // -------------------------------------------------------------------------
  // CSV UPLOAD (Batch Prediction Testing)
  // -------------------------------------------------------------------------
  uploadCsv: protectedProcedure
    .input(z.object({
      base64Data: z.string(),
      fileName: z.string(),
    }))
    .mutation(async ({ input, ctx }) => {
      const { base64Data, fileName } = input;
      
      // Decode and parse CSV
      const csvContent = Buffer.from(base64Data, 'base64').toString('utf-8');
      const rows = csvContent.split('\n').map(row => row.split(','));
      const headers = rows[0];
      const dataRows = rows.slice(1).filter(row => row.length > 1);

      // Validate required columns
      const requiredColumns = ['race_id', 'horse_name', 'track_name', 'race_date'];
      const missingColumns = requiredColumns.filter(col => !headers.includes(col));
      
      if (missingColumns.length > 0) {
        throw new Error(`Missing required columns: ${missingColumns.join(', ')}`);
      }

      // Process rows and trigger predictions
      const uploadResult: z.infer<typeof csvUploadSchema> = {
        fileName,
        fileSize: base64Data.length,
        rowCount: dataRows.length,
        columnCount: headers.length,
        uploadedAt: new Date(),
        processingStatus: 'processing',
        validationResults: {
          validRows: 0,
          invalidRows: 0,
          warnings: [],
        },
      };

      // Async batch prediction job (implement with queue/worker)
      ctx.jobQueue.add('batch-prediction', {
        uploadId: crypto.randomUUID(),
        rows: dataRows,
        headers,
        userId: ctx.user.id,
      });

      return uploadResult;
    }),

  // -------------------------------------------------------------------------
  // DASHBOARD DATA - Comprehensive Analytics
  // -------------------------------------------------------------------------
  dashboard: protectedProcedure
    .input(z.object({
      days: z.number().int().positive().default(30),
    }))
    .query(async ({ input, ctx }) => {
      const startDate = new Date(Date.now() - input.days * 24 * 60 * 60 * 1000);
      
      // Fetch overview metrics
      const overview = await ctx.procedures.predictions.analytics({
        startDate,
        endDate: new Date(),
        includeModelBreakdown: true,
      });

      // Performance trend (daily aggregates)
      const performanceTrend = await ctx.db.$queryRaw`
        SELECT 
          DATE(race_date) as date,
          AVG(CASE WHEN predicted_position = 1 AND actual_position = 1 THEN 1.0 ELSE 0.0 END) as top1_accuracy,
          AVG(roi_value) as roi,
          COUNT(*) as races_count
        FROM prediction_history
        WHERE race_date >= ${startDate}
          AND actual_position IS NOT NULL
        GROUP BY DATE(race_date)
        ORDER BY date DESC
      `;

      // Track-level performance
      const trackPerformance = await ctx.db.$queryRaw`
        SELECT 
          track_name,
          COUNT(*) as races_count,
          AVG(CASE WHEN predicted_position = 1 AND actual_position = 1 THEN 1.0 ELSE 0.0 END) as top1_accuracy,
          AVG(roi_value) as roi,
          AVG(CASE WHEN predicted_probability > (1.0 / starting_odds) THEN 1.0 ELSE 0.0 END) as market_beat_rate
        FROM prediction_history
        WHERE race_date >= ${startDate}
          AND actual_position IS NOT NULL
        GROUP BY track_name
        ORDER BY races_count DESC
        LIMIT 20
      `;

      // Model health monitoring
      const modelHealth = overview.modelBreakdown?.map(model => ({
        modelName: model.modelName,
        status: model.accuracy > 0.35 ? 'healthy' as const : 'degraded' as const,
        lastPredictionTime: new Date(), // Query from model_prediction_log
        avgLatency: 45, // From monitoring metrics
        errorRate: 0.001,
      })) || [];

      // Alerts & anomalies
      const alerts = await ctx.db.systemAlert.findMany({
        where: {
          timestamp: { gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) },
          acknowledged: false,
        },
        orderBy: { timestamp: 'desc' },
        take: 10,
      });

      return {
        overview,
        performanceTrend,
        trackPerformance,
        modelHealth,
        alerts,
      } satisfies z.infer<typeof analyticsDashboardSchema>;
    }),
});

// Helper function for weighted ensemble
function getModelWeight(modelName: string): number {
  const weights: Record<string, number> = {
    'LightGBM_Ranker': 0.35,
    'XGBoost': 0.25,
    'LightGBM_Old': 0.20,
    'LogisticRegression': 0.12,
    'GradientBoosting': 0.08,
  };
  return weights[modelName] || 0;
}

function buildWhereClause(input: Partial<z.infer<typeof predictionFilterSchema>>) {
  const where: any = {};
  if (input.trackName) where.trackName = { contains: input.trackName, mode: 'insensitive' };
  if (input.trackCode) where.trackCode = input.trackCode;
  if (input.horseName) where.horseName = { contains: input.horseName, mode: 'insensitive' };
  if (input.dateFrom || input.dateTo) {
    where.raceDate = {};
    if (input.dateFrom) where.raceDate.gte = input.dateFrom;
    if (input.dateTo) where.raceDate.lte = input.dateTo;
  }
  if (input.minConfidence) where.confidenceScore = { gte: input.minConfidence };
  if (input.resultStatus && input.resultStatus !== 'all') {
    if (input.resultStatus === 'won') where.isWinner = true;
    else if (input.resultStatus === 'top3') where.isTop3 = true;
    else if (input.resultStatus === 'pending') where.actualPosition = null;
  }
  return where;
}
